# 11057

![오르막수](https://user-images.githubusercontent.com/72541544/126782653-93c106ad-bb60-4086-b9b2-1d955c6a66c3.png)

* 오르막수
* 문제를 보면 오르막 수는 자리가 오름차순을 이루는 수라고 한다.
  * 수가 같아도 오름차순으로 친다고 한다.
  * 수는 0으로 시작할 수 있다.
* 수의 길이 N이 주어졌을 때, 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.



**어떻게 풀어야할까?​**​😂​

숫자가 오름차순이고 같아도 된다.

i = 1일 때부터 살펴본다.

```tex
1) i = 1 일 때
0 1 2 3 4 5 6 7 8 9 

2) i = 2 일 때
00 01 02 03 04 05 06 07 08 09
11 12 13 14 15 16 17 18 19
~
99

3) i = 3 일 때
000 001 002 003 004 005 006 007 008 009
011 012 013 014 015 016 017 018 019
022 023 024 025 026 027 028 029
~
099
111 112 113 114 115 116 117 118 119
122 123 124 125 126 127 128 129
~
999
```

:fire:위 예시를 보자!:fire:

i = 2일 때,

```tex
00 01 02 03 04 05 06 07 08 09
```

이는 i = 1일 때

0 1 2 3 4 5 6 7 8 9와 같다.

또한 i = 3일 때를 보면

000에서 ~ 099까지를 본다면

이는, i = 2 에서 00 ~ 99의 개수와 같다.

그리고, i = 3 에서 111 부터 199까지는 i = 2 에서 11 부터 99까지이다.

보이는가?**:sunny:**

i = 1, i = 2에서도 

i = 1일 때 숫자를 순차적으로 더했을 때 10, 9, 8, 7, 6, 5, 4, 3, 2, 1로 나온다.

이는 i = 2 의 첫 번째는 10번, 두 번째는 9번, 세 번째는 8 ~ 마지막은 1이다.



결국 n번째 i번째 인덱스 값은 

```c++
number[n][i] = total[n-1][i]
```

이제 이를 이용하여 소스를 작성해보면 이렇다.:blush:



```c++
// f(n) = f(n-1) + (f(n-1) - f(n-2)f(0)) + (f(n-1) - (f(n-2)f(0) + f(n-2)f(1))) + ~ + (f(n-1) - (f(n-2)f(0) + f(n-2)f(1) + ~ + f(n-2)f(8)))

#include <iostream>
#include <cstdio>

using namespace std;


int N; // 수의 길이
int uphill_road[1001][11]; // 자리 값
int total[1001][11];  // 총합
int main(){
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);



    cin >> N;



    for(int i = 9;i >= 0;i--){
        uphill_road[1][i] = 1;   // 첫 번째 인덱스 값들을 1로 넣는다.

        if(i==9){
            total[1][i] = 1;   // 처음으로 숫자
            continue;
        }


        total[1][i] += total[1][i+1] + 1; // 현재 총 숫자 개수를 구한다.
    }

    for(int i=2;i<=N;i++){
        for(int j=9;j>=0;j--){
            uphill_road[i][j] = total[i-1][j]%10007;   // 이전 j열까지 총합이, 이번 j열의 값이 된다.
            if(j==9){
                total[i][j] = 1;
                continue;
            }

            total[i][j] = (total[i][j+1]%10007 + uphill_road[i][j]%10007)%10007;  
    		// 총합 = 이전 총합 + 현재 값
        }
    }



    printf("%d\n",total[N][0]%10007);






    return 0;
}

```





