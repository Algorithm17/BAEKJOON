# **DFS**

* DFS 개념 (Depth First Search, 깊이 우선 탐색)

  * 갈 수 있는만큼 깊게 가고, 더 이상 갈 수 없다면 이전 정점으로 돌아간다.
  * stack으로 구현

* DFS 사용할 때

  1) 첫 번째 위치를 스택에 넣는다.

  2) 맨 위에서 하나 빼낸 후, 그 위치에서 갈 수 있는 경로를 스택에 다 넣는다.

  3) 원하는 값을 찾을 때까지 2번을 반복한다.



# **BFS**

* BFS 개념 (Breath First Search, 넓이 우선 탐색)

  * 현재 정점에서 갈 수 있는 위치부터 끝까지 탐색해나감
  * queue으로 구현

* BFS 사용할 때

  1) 첫 번째 위치를 큐에 넣는다.

  2) 큐에 넣었던 값을 빼낸 후, 그 위치에서 갈 수 있는 경로를 큐에 넣는다.

  3) 원하는 값을 찾을 때까지 2번을 반복한다.



***dfs, bfs 주의할 점***

>이전에 방문했던 위치는 다시 방문하지 않는다.
>
>전에 방문하지 않았고, 값이 있다면 그 다음 위치로 선정될 수 있다.

![dfs, bfs](https://user-images.githubusercontent.com/72541544/126598348-85b497ce-1410-4181-b16c-890a9a43a868.png)



# DFS, BFS 문제 포인트

* 그래프로 탐색해야한다.
* 그래프는 인접행렬과 인접리스트로 표현할 수 있다.
  * ![인접행렬, 인접리스트](https://user-images.githubusercontent.com/72541544/126598353-fd91995b-31ba-4ae7-b267-794d0a1e77b6.png)
* 인접행렬
  * 연결되어있는 위치에 1을 넣어준다.
  * 0이라면 연결되어있지 않다고 생각하면 된다.
  * 장점
    * 구현이 쉽다. 노드 간의 연결여부를 알고 싶을 때 빠르게 확인할 수 있다.
  * 단점
    * 노드를 방문해보고 싶을 때 'adj(i)(1)'부터 'adj(i)(v)'를 모두 확인해봐야 하기 때문에 비효율적이다.
* 인접리스트
  * 각 정점에 인접한 정점들을 리스트로 표현하는 방법이다.
  * c++의 경우 vector 컨테이너를 이용하면 된다.
  * 장점
    * 실제로 연결되어 있는 노드의 정보만 담기 때문에 메모리를 적게 차지한다.
    * 모든 노드를 다 방문하는 경우 시간적 이점이 존재한다.
  * 단점
    * 노드간의 연결여부를 알기 위해서는 노드를 다 탐색해야 한다.



* 소스

```c++
#include <iostream>
#include <queue>
#include <cstring>
#define MAX 1001
using namespace std;

int n, m, v;
int a, b;
int map[MAX][MAX];
bool visited[MAX];
queue<int>q;

void bfs(int v) {
	visited[v] = 1;
	q.push(v);

	while (!q.empty()) {
		v = q.front();
		q.pop();
		cout << v << " ";
		for (int i = 1; i <= n; i++) {
			if (map[v][i]  && !visited[i]) {
				q.push(i);
				visited[i] = 1;
			}
		}
	}
}
// v : from, i : to
void dfs(int v) {
	cout << v << " ";
	visited[v] = 1;
	for (int i = 1; i <= n; i++) {
        // v와 i 정점이 서로 연결되어 있고
        // 아직 방문하지 않았다면
		if (map[v][i]  && !visited[i]) {
			dfs(i);
		}
	}
}

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0); cout.tie(0);

	cin >> n >> m >> v;
	for (int i = 0; i < m; i++) {
		cin >> a >> b;
		map[a][b] = map[b][a] = 1;
	}
	dfs(v);
	cout << '\n';
	memset(visited, false, sizeof(visited));
	bfs(v);
	cout << '\n';
}
```



### DFS, BFS





# 백트래킹(Backtracking)

일반적인 알고리즘이다. 

백트래킹은 **CSP(Constrain Staisfaction Problems)을 해결하기 위해 쓰인다.**

백트래킹은 **모든 조합의 수를 조건이 만족할 때 살펴본다.**

**N-Queen**문제에서 많이 사용된다.

> N * N 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.
>
> N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.

4 * 4 기준으로 문제를 풀어보자.

퀸은 칸을 기준으로 오와 열, 대각선 이동이 가능하다.

![퀸](https://user-images.githubusercontent.com/72541544/127507455-42e05791-3154-4acb-8756-b6346733fc7d.png)

첫 번째 퀸과 공격할 수 없게 배치할려면 2번째 줄은 3, 4번째 위치에 퀸을 놓아야 한다.

첫 번째 퀸의 위치를 (1, 1)로 하면 트리구조는 다음과 같다.

![가지치기](https://user-images.githubusercontent.com/72541544/127507471-e467ec24-4636-48c3-8d34-cbaeab755a13.png)

만약 이문제를 가지치기 하지않는 DFS로 풀이했다면 유망하지 않는 (2,1), (2,2) 지점도 검사를 했을 것이다.

이럴 경우, 더 큰 체스판에서 퀸을 놓는 경우의 수를 찾을 때 수많은 연산이 일어나게 된다.

(가지치기를 잘해야 한다.)

#### 백트래킹 4가지 절차

1) DFS 수행 : 먼저 평소와 같이 깊이우선탐색인 DFS를 수행하여 노드를 찾는다.

2) 유망한 노드 검토 : 방문한 노드를 포함해서 유망한 노드이면 서브트리로 이동하고 그렇지 않으면 백트래킹을 수행한다.

3) 방문한 노드의 하위 노드로 이동하여 다시 재귀를 통해 DFS를 수행한다.

4) 백트래킹 수행 : 방문한 노드를 가지치기를 하고 상위 노드로 백트래킹 한 후 DFS를 다시 수행한다.



ex) 백트래킹 4가지 절차를 이용하여, 2번 째 위치에 퀸을 놓는 방법

1) (1, 1) 에서 시작하여 DFS 수행을 통해 가장 첫번째 노드인 (2, 1) 지점으로 간다.

2) (2, 1) 노드를 검사해보니 첫번째 퀸의 이동반경에 포함되기 때문에 유망한 노드가 아니어서 백트래킹을 수행하여 상위 노드인 (1, 1) 지점으로 이동한다.

3) 다시 DFS 를 수행하여 다음 노드인 (2, 2) 로 이동한다.

4) (2, 2) 노드를 검사해보니 첫번째 퀸의 이동반경에 포함되기 때문에 유망한 노드가 아니어서 백트래킹을 수행하여 상위 노드인 (1, 1) 지점으로 이동한다.

5) 다시 DFS 를 수행하여 다음 노드인 (2, 3) 로 이동한다.

6) (2, 3) 노드를 검사해보니 첫번째 퀸의 이동반경에 포함되지 않아서 유망한 노드가 되었다. 이제 (2, 3) 을 기준으로 DFS 를 수행하여 3번째 퀸의 위치를 찾는다.



이렇듯 가지치기를 통해서 해당 노드가 유망하지 않으면 가차없이 짤라버려서 탐색하는 경로를 최소한으로 줄일 수 있게 된다.









**참고자료**

* https://velog.io/@513sojin/C%EB%B0%B1%EC%A4%80-1260-DFS%EC%99%80BFS
* https://jeongdowon.medium.com/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-backtracking-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-13492b18bfa1
* https://thd0011.tistory.com/19

